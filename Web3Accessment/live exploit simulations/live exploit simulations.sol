// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

/// @title LiveExploitsSimulationSuite.sol
/// @notice On-chain analogues of “Live Exploits Simulations” patterns:
///   Types: RealTimeMonitoring, ReplaySimulation, HybridLoad, AdversarialTesting  
///   AttackTypes: ZeroDay, FuzzCrash, FrontRunning, ResourceExhaustion  
///   DefenseTypes: AccessControl, Sandbox, RateLimit, SignatureValidation, AuditLogging

enum LESimType            { RealTimeMonitoring, ReplaySimulation, HybridLoad, AdversarialTesting }
enum LESimAttackType      { ZeroDay, FuzzCrash, FrontRunning, ResourceExhaustion }
enum LESimDefenseType     { AccessControl, Sandbox, RateLimit, SignatureValidation, AuditLogging }

error LES__NotAuthorized();
error LES__TooManyRequests();
error LES__InvalidSignature();
error LES__ScenarioMissing();

////////////////////////////////////////////////////////////////////////////////
// 1) VULNERABLE SIMULATOR
//    • ❌ no controls: anyone may trigger or log simulations → ZeroDay
////////////////////////////////////////////////////////////////////////////////
contract LiveExploitsSimVuln {
    struct Simulation { uint256 id; LESimType simType; string details; }
    mapping(uint256 => Simulation) public sims;
    uint256 public nextId;

    event SimCreated(
        address indexed who,
        uint256           simId,
        LESimType         simType,
        LESimAttackType   attack
    );
    event SimRun(
        address indexed who,
        uint256           simId,
        LESimType         simType,
        LESimAttackType   attack
    );

    function createSim(string calldata details, LESimType simType) external {
        sims[nextId] = Simulation(nextId, simType, details);
        emit SimCreated(msg.sender, nextId, simType, LESimAttackType.ZeroDay);
        nextId++;
    }

    function runSim(uint256 simId) external {
        Simulation storage s = sims[simId];
        emit SimRun(msg.sender, simId, s.simType, LESimAttackType.FuzzCrash);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 2) ATTACK STUB
//    • simulates zero-day, fuzz crash, front-run, exhaustion
////////////////////////////////////////////////////////////////////////////////
contract Attack_LiveExploitsSim {
    LiveExploitsSimVuln public target;
    uint256 public lastId;

    constructor(LiveExploitsSimVuln _t) { target = _t; }

    function exploitZeroDay(string calldata details) external {
        target.createSim(details, LESimType.RealTimeMonitoring);
        lastId = target.nextId() - 1;
    }

    function fuzzCrash(uint256 count) external {
        for (uint i = 0; i < count; i++) {
            target.runSim(lastId);
        }
    }

    function frontRun(uint256 simId) external {
        target.runSim(simId);
    }

    function exhaustResources() external {
        // simulate resource exhaustion by creating many
        for (uint i = 0; i < 10; i++) {
            target.createSim("load", LESimType.HybridLoad);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
// 3) SAFE WITH ACCESS CONTROL
//    • ✅ Defense: AccessControl – only owner may create/run
////////////////////////////////////////////////////////////////////////////////
contract LiveExploitsSimSafeAccess {
    struct Simulation { uint256 id; LESimType simType; string details; }
    mapping(uint256 => Simulation) public sims;
    uint256 public nextId;
    address public owner;

    event SimCreated(
        address indexed who,
        uint256           simId,
        LESimType         simType,
        LESimDefenseType  defense
    );
    event SimRun(
        address indexed who,
        uint256           simId,
        LESimType         simType,
        LESimDefenseType  defense
    );

    constructor() { owner = msg.sender; }

    modifier onlyOwner() {
        if (msg.sender != owner) revert LES__NotAuthorized();
        _;
    }

    function createSim(string calldata details, LESimType simType) external onlyOwner {
        sims[nextId] = Simulation(nextId, simType, details);
        emit SimCreated(msg.sender, nextId, simType, LESimDefenseType.AccessControl);
        nextId++;
    }

    function runSim(uint256 simId) external onlyOwner {
        Simulation storage s = sims[simId];
        emit SimRun(msg.sender, simId, s.simType, LESimDefenseType.AccessControl);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 4) SAFE WITH SANDBOX & RATE LIMIT
//    • ✅ Defense: Sandbox – isolate runs  
//               RateLimit – cap operations per block
////////////////////////////////////////////////////////////////////////////////
contract LiveExploitsSimSafeSandbox {
    struct Simulation { uint256 id; LESimType simType; string details; }
    mapping(uint256 => Simulation) public sims;
    uint256 public nextId;
    mapping(address => uint256) public lastBlock;
    mapping(address => uint256) public opsInBlock;
    uint256 public constant MAX_OPS = 5;

    event SimCreated(
        address indexed who,
        uint256           simId,
        LESimType         simType,
        LESimDefenseType  defense
    );
    event SimRun(
        address indexed who,
        uint256           simId,
        LESimType         simType,
        LESimDefenseType  defense
    );

    error LES__TooManyRequests();

    function createSim(string calldata details, LESimType simType) external {
        if (block.number != lastBlock[msg.sender]) {
            lastBlock[msg.sender]    = block.number;
            opsInBlock[msg.sender] = 0;
        }
        opsInBlock[msg.sender]++;
        if (opsInBlock[msg.sender] > MAX_OPS) revert LES__TooManyRequests();

        sims[nextId] = Simulation(nextId, simType, details);
        emit SimCreated(msg.sender, nextId, simType, LESimDefenseType.Sandbox);
        nextId++;
    }

    function runSim(uint256 simId) external {
        if (sims[simId].id != simId) revert LES__ScenarioMissing();
        // sandbox stub: no state change outside here
        emit SimRun(msg.sender, simId, sims[simId].simType, LESimDefenseType.Sandbox);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 5) SAFE ADVANCED WITH SIGNATURE VALIDATION & AUDIT LOGGING
//    • ✅ Defense: SignatureValidation – require admin‐signed requests  
//               AuditLogging       – record each action
////////////////////////////////////////////////////////////////////////////////
contract LiveExploitsSimSafeAdvanced {
    struct Simulation { uint256 id; LESimType simType; string details; }
    mapping(uint256 => Simulation) public sims;
    uint256 public nextId;
    address public signer;

    event SimCreated(
        address indexed who,
        uint256           simId,
        LESimType         simType,
        LESimDefenseType  defense
    );
    event SimRun(
        address indexed who,
        uint256           simId,
        LESimType         simType,
        LESimDefenseType  defense
    );
    event AuditLog(
        address indexed who,
        string            action,
        uint256           simId,
        LESimDefenseType  defense
    );

    error LES__InvalidSignature();

    constructor(address _signer) {
        signer = _signer;
    }

    function createSim(
        string calldata details,
        LESimType simType,
        bytes calldata sig
    ) external {
        bytes32 h = keccak256(abi.encodePacked("CREATE", msg.sender, details, simType));
        bytes32 eth = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", h));
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(sig,(uint8,bytes32,bytes32));
        if (ecrecover(eth, v, r, s) != signer) revert LES__InvalidSignature();

        sims[nextId] = Simulation(nextId, simType, details);
        emit SimCreated(msg.sender, nextId, simType, LESimDefenseType.SignatureValidation);
        emit AuditLog(msg.sender, "createSim", nextId, LESimDefenseType.AuditLogging);
        nextId++;
    }

    function runSim(
        uint256 simId,
        bytes calldata sig
    ) external {
        if (sims[simId].id != simId) revert LES__ScenarioMissing();
        bytes32 h = keccak256(abi.encodePacked("RUN", msg.sender, simId));
        bytes32 eth = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", h));
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(sig,(uint8,bytes32,bytes32));
        if (ecrecover(eth, v, r, s) != signer) revert LES__InvalidSignature();

        emit SimRun(msg.sender, simId, sims[simId].simType, LESimDefenseType.SignatureValidation);
        emit AuditLog(msg.sender, "runSim", simId, LESimDefenseType.AuditLogging);
    }
}
