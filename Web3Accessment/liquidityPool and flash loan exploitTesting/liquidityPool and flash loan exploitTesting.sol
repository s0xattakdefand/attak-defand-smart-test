// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title LiquidityPoolsFlashLoanExploitAttackDefense - Attack and Defense Simulation for Flash Loan and Liquidity Pool Exploits in Web3 Smart Contracts
/// @author ChatGPT

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

/// @notice Secure liquidity pool protected against flashloan attacks
contract SecureLiquidityPool {
    address public tokenA;
    address public tokenB;
    uint256 public reserveA;
    uint256 public reserveB;
    uint256 public lastUpdateBlock;

    bool private locked;

    modifier lock() {
        require(!locked, "Reentrancy Guard");
        locked = true;
        _;
        locked = false;
    }

    constructor(address _tokenA, address _tokenB) {
        tokenA = _tokenA;
        tokenB = _tokenB;
        lastUpdateBlock = block.number;
    }

    function provideLiquidity(uint256 amountA, uint256 amountB) external lock {
        require(amountA > 0 && amountB > 0, "Zero amounts not allowed");

        IERC20(tokenA).transferFrom(msg.sender, address(this), amountA);
        IERC20(tokenB).transferFrom(msg.sender, address(this), amountB);

        reserveA += amountA;
        reserveB += amountB;

        lastUpdateBlock = block.number;
    }

    function swap(address fromToken, uint256 amountIn) external lock returns (uint256 amountOut) {
        require(fromToken == tokenA || fromToken == tokenB, "Invalid token");

        if (fromToken == tokenA) {
            require(reserveA > 0 && reserveB > 0, "Empty pool");
            uint256 k = reserveA * reserveB;
            uint256 newReserveA = reserveA + amountIn;
            uint256 newReserveB = k / newReserveA;
            amountOut = reserveB - newReserveB;

            require(amountOut > 0, "Invalid output");
            IERC20(tokenA).transferFrom(msg.sender, address(this), amountIn);
            IERC20(tokenB).transfer(msg.sender, amountOut);

            reserveA = newReserveA;
            reserveB = newReserveB;
        } else {
            require(reserveA > 0 && reserveB > 0, "Empty pool");
            uint256 k = reserveA * reserveB;
            uint256 newReserveB = reserveB + amountIn;
            uint256 newReserveA = k / newReserveB;
            amountOut = reserveA - newReserveA;

            require(amountOut > 0, "Invalid output");
            IERC20(tokenB).transferFrom(msg.sender, address(this), amountIn);
            IERC20(tokenA).transfer(msg.sender, amountOut);

            reserveA = newReserveA;
            reserveB = newReserveB;
        }

        lastUpdateBlock = block.number;
    }

    function getReserves() external view returns (uint256, uint256) {
        return (reserveA, reserveB);
    }
}

/// @notice Attack contract simulating flashloan exploit attempt
contract FlashLoanLiquidityIntruder {
    address public targetPool;
    address public tokenA;
    address public tokenB;

    constructor(address _targetPool, address _tokenA, address _tokenB) {
        targetPool = _targetPool;
        tokenA = _tokenA;
        tokenB = _tokenB;
    }

    function simulateFlashLoanAttack(uint256 flashBorrowAmount) external {
        // Assume flashloaned flashBorrowAmount of tokenA
        IERC20(tokenA).transferFrom(msg.sender, address(this), flashBorrowAmount);

        // Now attempt to unbalance pool
        IERC20(tokenA).approve(targetPool, flashBorrowAmount);
        (bool success, ) = targetPool.call(
            abi.encodeWithSignature("swap(address,uint256)", tokenA, flashBorrowAmount)
        );
        require(success, "Swap failed");

        // Attempt to drain liquidity imbalance
        (uint256 reserveA, uint256 reserveB) = SecureLiquidityPool(targetPool).getReserves();
        require(reserveA < reserveB, "Flashloan manipulation failed");
    }
}
