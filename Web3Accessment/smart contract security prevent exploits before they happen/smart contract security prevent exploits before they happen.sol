// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

/// @title SmartContractSecurityPreventionSuite.sol
/// @notice On-chain analogues of “Smart Contract Security: Prevent Exploits Before They Happen”:
///   Types: StaticAnalysis, FormalVerification, FuzzTesting, RuntimeMonitoring  
///   AttackTypes: Reentrancy, IntegerOverflow, UncheckedCall, FrontRunning  
///   DefenseTypes: StaticAnalysis, FormalVerification, FuzzTesting, Watchdog, RateLimit

enum SCSPType             { StaticAnalysis, FormalVerification, FuzzTesting, RuntimeMonitoring }
enum SCSPAttackType       { Reentrancy, IntegerOverflow, UncheckedCall, FrontRunning }
enum SCSPDefenseType      { StaticAnalysis, FormalVerification, FuzzTesting, Watchdog, RateLimit }

error SCSP__ReentrancyDetected();
error SCSP__OverflowDetected();
error SCSP__UncheckedCall();
error SCSP__TooManyRequests();
error SCSP__InvalidSignature();

////////////////////////////////////////////////////////////////////////////////
// 1) VULNERABLE PAYMENT CONTRACT
//    • ❌ no checks: reentrancy & overflows possible → Reentrancy, IntegerOverflow
////////////////////////////////////////////////////////////////////////////////
contract SCSPVuln {
    mapping(address => uint256) public balances;
    event Withdrawal(address indexed who, uint256 amount, SCSPType stype, SCSPAttackType attack);

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external {
        // vulnerable to reentrancy and overflow
        if (balances[msg.sender] < amount) revert();
        balances[msg.sender] -= amount;
        (bool ok,) = msg.sender.call{value: amount}("");
        require(ok);
        emit Withdrawal(msg.sender, amount, SCSPType.StaticAnalysis, SCSPAttackType.Reentrancy);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 2) ATTACK STUB
//    • simulates reentrancy and overflow exploits
////////////////////////////////////////////////////////////////////////////////
contract Attack_SCSP {
    SCSPVuln public target;
    constructor(SCSPVuln _t) { target = _t; }

    receive() external payable {
        if (address(target).balance >= msg.value) {
            target.withdraw(msg.value);
        }
    }

    function attackReentrancy() external payable {
        target.deposit{value: msg.value}();
        target.withdraw(msg.value);
    }

    function attackOverflow(uint256 huge) external {
        // force overflow on subtraction
        target.withdraw(huge);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 3) SAFE WITH STATIC ANALYSIS GUARD
//    • ✅ Defense: StaticAnalysis – reentrancy guard
////////////////////////////////////////////////////////////////////////////////
contract SCSPSafeStatic {
    mapping(address => uint256) public balances;
    bool private _entered;

    event Withdrawal(address indexed who, uint256 amount, SCSPType stype, SCSPDefenseType defense);

    modifier noReentry() {
        require(!_entered, "reentrancy");
        _entered = true;
        _;
        _entered = false;
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external noReentry {
        require(balances[msg.sender] >= amount, "insufficient");
        balances[msg.sender] -= amount;
        (bool ok,) = msg.sender.call{value: amount}("");
        require(ok);
        emit Withdrawal(msg.sender, amount, SCSPType.StaticAnalysis, SCSPDefenseType.StaticAnalysis);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 4) SAFE WITH FORMAL VERIFICATION & RATE LIMIT
//    • ✅ Defense: FormalVerification – overflow check  
//               RateLimit         – cap withdrawals per block
////////////////////////////////////////////////////////////////////////////////
contract SCSPSafeFormal {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public lastBlock;
    mapping(address => uint256) public callsInBlock;
    uint256 public constant MAX_CALLS = 3;

    event Withdrawal(address indexed who, uint256 amount, SCSPType stype, SCSPDefenseType defense);

    error TooManyRequests();

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external {
        // rate limit
        if (block.number != lastBlock[msg.sender]) {
            lastBlock[msg.sender] = block.number;
            callsInBlock[msg.sender] = 0;
        }
        callsInBlock[msg.sender]++;
        if (callsInBlock[msg.sender] > MAX_CALLS) revert TooManyRequests();

        // formally verified check: prevents underflow
        require(balances[msg.sender] >= amount, "insufficient");
        balances[msg.sender] -= amount;
        (bool ok,) = msg.sender.call{value: amount}("");
        require(ok);
        emit Withdrawal(msg.sender, amount, SCSPType.FormalVerification, SCSPDefenseType.FormalVerification);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 5) SAFE ADVANCED WITH FUZZ TESTING & WATCHDOG & SIGNATURE VALIDATION
//    • ✅ Defense: FuzzTesting – gas/time check stub  
//               Watchdog       – detect abnormal patterns  
//               SignatureValidation – administrative override
////////////////////////////////////////////////////////////////////////////////
contract SCSPSafeAdvanced {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public withdrawCount;
    address public signer;

    event Withdrawal(address indexed who, uint256 amount, SCSPType stype, SCSPDefenseType defense);
    event Alert(address indexed who, string reason, SCSPDefenseType defense);

    error InvalidSignature();

    constructor(address _signer) {
        signer = _signer;
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(
        uint256 amount,
        bytes calldata sig
    ) external {
        // signature validation for large withdraw
        if (amount > 1 ether) {
            bytes32 h = keccak256(abi.encodePacked(msg.sender, amount));
            bytes32 eth = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", h));
            (uint8 v, bytes32 r, bytes32 s) = abi.decode(sig,(uint8,bytes32,bytes32));
            if (ecrecover(eth, v, r, s) != signer) revert InvalidSignature();
        }

        // watchdog: detect too many withdrawals
        withdrawCount[msg.sender]++;
        if (withdrawCount[msg.sender] > 10) {
            emit Alert(msg.sender, "excessive withdrawals", SCSPDefenseType.Watchdog);
        }

        require(balances[msg.sender] >= amount, "insufficient");
        balances[msg.sender] -= amount;
        (bool ok,) = msg.sender.call{value: amount}("");
        require(ok);
        emit Withdrawal(msg.sender, amount, SCSPType.RuntimeMonitoring, SCSPDefenseType.Watchdog);
    }
}
