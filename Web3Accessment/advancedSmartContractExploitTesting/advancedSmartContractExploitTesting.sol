// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

/// @title AdvancedSmartContractExploitTestingSuite.sol
/// @notice On-chain analogues of “Advanced Smart Contract Exploit Testing” patterns:
///   Types: StaticAnalysis, FuzzTesting, SymbolicExecution, HybridSimulation  
///   AttackTypes: CoverageGap, CrashFailure, FalseNegative, Timeout  
///   DefenseTypes: AccessControl, FuzzerGuard, CoverageEnforcement, RateLimit, SignatureValidation

enum ASTType                { StaticAnalysis, FuzzTesting, SymbolicExecution, HybridSimulation }
enum ASTAttackType          { CoverageGap, CrashFailure, FalseNegative, Timeout }
enum ASTDefenseType         { AccessControl, FuzzerGuard, CoverageEnforcement, RateLimit, SignatureValidation }

error AST__NotAuthorized();
error AST__InvalidSpec();
error AST__TooManyRequests();
error AST__InvalidSignature();
error AST__CoverageNotMet();

////////////////////////////////////////////////////////////////////////////////
// 1) VULNERABLE TEST MANAGER
//    • ❌ no checks: anyone may schedule or run tests → CoverageGap, CrashFailure
////////////////////////////////////////////////////////////////////////////////
contract ASTVuln {
    struct Test { uint256 id; ASTType ttype; string spec; }
    mapping(uint256 => Test) public tests;
    uint256 public nextId;

    event TestScheduled(
        address indexed who,
        uint256           testId,
        ASTType           ttype,
        ASTAttackType     attack
    );
    event TestRun(
        address indexed who,
        uint256           testId,
        ASTType           ttype,
        ASTAttackType     attack
    );

    function scheduleTest(string calldata spec, ASTType ttype) external {
        tests[nextId] = Test(nextId, ttype, spec);
        emit TestScheduled(msg.sender, nextId, ttype, ASTAttackType.CoverageGap);
        nextId++;
    }

    function runTest(uint256 testId) external {
        Test storage t = tests[testId];
        emit TestRun(msg.sender, testId, t.ttype, ASTAttackType.CrashFailure);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 2) ATTACK STUB
//    • simulates coverage gaps, crashes, false negatives, timeouts
////////////////////////////////////////////////////////////////////////////////
contract Attack_AST {
    ASTVuln public target;
    uint256 public lastId;

    constructor(ASTVuln _t) { target = _t; }

    function bypassSchedule(string calldata spec) external {
        target.scheduleTest(spec, ASTType.StaticAnalysis);
        lastId = target.nextId() - 1;
    }

    function triggerCrash(uint256 id) external {
        target.runTest(id);
    }

    function falseNeg(uint256 id) external {
        // simulate a test falsely passing
        target.runTest(id);
    }

    function timeoutRun(uint256 id) external {
        target.runTest(id);
    }

    function replayLast() external {
        target.runTest(lastId);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 3) SAFE WITH ACCESS CONTROL
//    • ✅ Defense: AccessControl – only owner may schedule or run tests
////////////////////////////////////////////////////////////////////////////////
contract ASTSafeAccess {
    struct Test { uint256 id; ASTType ttype; string spec; }
    mapping(uint256 => Test) public tests;
    uint256 public nextId;
    address public owner;

    event TestScheduled(
        address indexed who,
        uint256           testId,
        ASTType           ttype,
        ASTDefenseType    defense
    );
    event TestRun(
        address indexed who,
        uint256           testId,
        ASTType           ttype,
        ASTDefenseType    defense
    );

    constructor() { owner = msg.sender; }

    modifier onlyOwner() {
        if (msg.sender != owner) revert AST__NotAuthorized();
        _;
    }

    function scheduleTest(string calldata spec, ASTType ttype) external onlyOwner {
        tests[nextId] = Test(nextId, ttype, spec);
        emit TestScheduled(msg.sender, nextId, ttype, ASTDefenseType.AccessControl);
        nextId++;
    }

    function runTest(uint256 testId) external onlyOwner {
        Test storage t = tests[testId];
        emit TestRun(msg.sender, testId, t.ttype, ASTDefenseType.AccessControl);
    }
}

////////////////////////////////////////////////////////////////////////////////
// 4) SAFE WITH FUZZ GUARD & RATE LIMIT
//    • ✅ Defense: FuzzerGuard – require nonempty spec  
//               RateLimit   – cap schedules/runs per block
////////////////////////////////////////////////////////////////////////////////
contract ASTSafeValidate {
    struct Test { uint256 id; ASTType ttype; string spec; }
    mapping(uint256 => Test) public tests;
    uint256 public nextId;
    mapping(address => uint256) public lastBlock;
    mapping(address => uint256) public opsInBlock;
    uint256 public constant MAX_OPS = 5;

    event TestScheduled(
        address indexed who,
        uint256           testId,
        ASTType           ttype,
        ASTDefenseType    defense
    );
    event TestRun(
        address indexed who,
        uint256           testId,
        ASTType           ttype,
        ASTDefenseType    defense
    );

    error AST__TooManyRequests();
    error AST__InvalidSpec();

    function scheduleTest(string calldata spec, ASTType ttype) external {
        if (bytes(spec).length == 0) revert AST__InvalidSpec();
        _rateLimit();
        tests[nextId] = Test(nextId, ttype, spec);
        emit TestScheduled(msg.sender, nextId, ttype, ASTDefenseType.FuzzerGuard);
        nextId++;
    }

    function runTest(uint256 testId) external {
        _rateLimit();
        Test storage t = tests[testId];
        if (bytes(t.spec).length == 0) revert AST__InvalidSpec();
        emit TestRun(msg.sender, testId, t.ttype, ASTDefenseType.FuzzerGuard);
    }

    function _rateLimit() internal {
        if (block.number != lastBlock[msg.sender]) {
            lastBlock[msg.sender] = block.number;
            opsInBlock[msg.sender] = 0;
        }
        opsInBlock[msg.sender]++;
        if (opsInBlock[msg.sender] > MAX_OPS) revert AST__TooManyRequests();
    }
}

////////////////////////////////////////////////////////////////////////////////
// 5) SAFE ADVANCED WITH SIGNATURE VALIDATION & AUDIT LOGGING
//    • ✅ Defense: SignatureValidation – require admin signature  
//               AuditLogging       – record all actions
////////////////////////////////////////////////////////////////////////////////
contract ASTSafeAdvanced {
    struct Test { uint256 id; ASTType ttype; string spec; }
    mapping(uint256 => Test) public tests;
    uint256 public nextId;
    address public signer;

    event TestScheduled(
        address indexed who,
        uint256           testId,
        ASTType           ttype,
        ASTDefenseType    defense
    );
    event TestRun(
        address indexed who,
        uint256           testId,
        ASTType           ttype,
        ASTDefenseType    defense
    );
    event AuditLog(
        address indexed who,
        string            action,
        uint256           testId,
        ASTDefenseType    defense
    );

    error AST__InvalidSignature();

    constructor(address _signer) { signer = _signer; }

    function scheduleTest(
        string calldata spec,
        ASTType ttype,
        bytes calldata sig
    ) external {
        bytes32 h = keccak256(abi.encodePacked(msg.sender, spec, ttype));
        bytes32 eth = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", h));
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(sig,(uint8,bytes32,bytes32));
        if (ecrecover(eth, v, r, s) != signer) revert AST__InvalidSignature();

        tests[nextId] = Test(nextId, ttype, spec);
        emit TestScheduled(msg.sender, nextId, ttype, ASTDefenseType.SignatureValidation);
        emit AuditLog(msg.sender, "scheduleTest", nextId, ASTDefenseType.AuditLogging);
        nextId++;
    }

    function runTest(
        uint256 testId,
        bytes calldata sig
    ) external {
        Test storage t = tests[testId];
        bytes32 h = keccak256(abi.encodePacked(msg.sender, testId));
        bytes32 eth = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", h));
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(sig,(uint8,bytes32,bytes32));
        if (ecrecover(eth, v, r, s) != signer) revert AST__InvalidSignature();

        emit TestRun(msg.sender, testId, t.ttype, ASTDefenseType.SignatureValidation);
        emit AuditLog(msg.sender, "runTest", testId, ASTDefenseType.AuditLogging);
    }
}
