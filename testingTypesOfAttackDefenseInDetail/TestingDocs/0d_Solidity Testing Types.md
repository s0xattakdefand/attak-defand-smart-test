| Testing Type                   | Purpose / Use Case                                                                 | How It Works in Your Security Lab                                                                    |
| ------------------------------ | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| **Unit Testing**               | Test isolated smart contract functions for expected inputs/outputs                 | Validate that attack vectors (e.g. reentrancy) or defenses (e.g. reentrancy guards) behave correctly |
| **Integration Testing**        | Test interaction between multiple contracts or protocols                           | Simulate attack chains that involve routers, token contracts, or oracles                             |
| **Property-Based Testing**     | Fuzz function inputs to explore edge cases                                         | Auto-discover Zero-Day vectors or entropy-sensitive drift (e.g., fallback abuse)                     |
| **Fuzz Testing**               | Randomized input mutation for entropy drift, selector collision, invalid calls     | Detect unexpected state changes, access control bypass, gas griefs, etc.                             |
| **Invariant Testing**          | Assert that certain properties (e.g., total supply, locked funds) always hold      | Ensure that no exploit can break protocol invariants (e.g., locked funds stay locked)                |
| **Snapshot Testing**           | Record state snapshots and compare post-action diffs                               | Detect tampering or drift in storage across exploit execution                                        |
| **Regression Testing**         | Catch reintroduced bugs or failed patches                                          | Lock in previous fixes for exploits; test old payloads vs. new defenses                              |
| **Gas Testing**                | Measure gas costs to detect gas bombs or inefficiencies                            | Flag DoS-style attacks or defense inefficiencies via loop, fallback, or recursion                    |
| **Replay Testing**             | Replay real exploit calldata or test vector from chain logs                        | Simulate real-world hacks to ensure defenses now mitigate them                                       |
| **Access Control Testing**     | Ensure correct role/permission boundaries                                          | Prevent elevation attacks, ensure `onlyOwner`, `RBAC`, `BitGuard`, etc., are effective               |
| **Mutation Testing**           | Modify function signatures, storage layout, or selector entropy to test robustness | Simulates ABI drift, zombie selector exploits, and storage slot injection vulnerabilities            |
| **Time/Block Testing**         | Manipulate block.timestamp or block.number                                         | Useful for attacks relying on timelocks, cooldowns, TWAP/TWAMM drift                                 |
| **Event-Based Testing**        | Validate event emissions or detect missing logs                                    | Ensures traceability; detects event suppression or spoofing attacks                                  |
| **Fork Testing**               | Fork a real chain state and simulate your exploit                                  | Attack contracts as they exist in production (e.g., Curve, Aave) with real balances                  |
| **Chain Differential Testing** | Compare behavior across multiple chains/forks                                      | Detect behavior differences due to opcode changes, gas pricing, or storage limits                    |
| **Oracle Testing**             | Test how your contracts respond to price or data oracle manipulation               | Simulate fake prices, stale rounds, or oracle front-runs                                             |
| **ZK/MetaTx Testing**          | Verify proof-based access, relayer security, and gasless call integrity            | Ensure signature replay protection, Semaphore access control, ZK-gated execution                     |
| **Concurrency / Race Testing** | Test how the contract behaves with fast sequence/multi-call submissions            | Detect reentrancy, race conditions, frontruns, and router feedback loops                             |
| **Fallback Testing**           | Test undefined selectors, fallback logic, receive() attacks                        | Validate fallback drift abuse, rogue calls, and gas griefs via low-level calls                       |
| **Entropy Drift Testing**      | Log and test changes in selector entropy or hash values across versions            | Detect replayable payloads or identifier collision (e.g. mutated function names)                     |
