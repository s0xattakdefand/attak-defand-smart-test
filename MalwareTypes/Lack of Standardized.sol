// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title LackOfStandardizationAttackDefense - Full Attack and Defense Simulation for Lack of Standardization Risks in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Token Contract (Custom Token Not Following ERC20 Standard Properly)
contract InsecureCustomToken {
    mapping(address => uint256) public balances;

    constructor() {
        balances[msg.sender] = 1000000 ether;
    }

    function transfer(address to, uint256 amount) external {
        require(balances[msg.sender] >= amount, "Not enough balance");
        balances[msg.sender] -= amount;
        balances[to] += amount;
        // BAD: No boolean return value!
    }

    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }
}

/// @notice Secure ERC20 Token Using OpenZeppelin Interface
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

/// @notice Secure Standard ERC20-Compliant Token
contract SecureStandardToken is IERC20 {
    string public constant name = "SecureToken";
    string public constant symbol = "SEC";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;

    mapping(address => uint256) private balances;

    constructor() {
        balances[msg.sender] = 1000000 ether;
        totalSupply = 1000000 ether;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        balances[recipient] += amount;
        return true;
    }
}

/// @notice Attack contract simulating failure due to non-standardized function expectations
contract LackOfStandardizationIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function tryTransfer(address to, uint256 amount) external returns (bool success, bytes memory result) {
        (success, result) = targetInsecure.call(
            abi.encodeWithSignature("transfer(address,uint256)", to, amount)
        );
        // Might revert or behave unexpectedly because function doesn't return a bool
    }
}
