// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title SybilAttackDefense - Full Attack and Defense Simulation for Sybil Attacks in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Registration Contract (Anyone Can Register Unlimited Times)
contract InsecureRegistration {
    mapping(address => bool) public registered;
    uint256 public totalRegistrations;

    event Registered(address indexed user);

    function register() external {
        registered[msg.sender] = true;
        totalRegistrations++;
        emit Registered(msg.sender);
    }
}

/// @notice Secure Sybil-Resistant Registration (Stake Required + Optional Human Proof)
contract SecureSybilResistantRegistration {
    mapping(address => bool) public registered;
    uint256 public totalRegistrations;
    uint256 public constant STAKE_AMOUNT = 0.1 ether;
    address public admin;

    event Registered(address indexed user);
    event StakeRefunded(address indexed user);

    constructor() {
        admin = msg.sender;
    }

    modifier notRegistered() {
        require(!registered[msg.sender], "Already registered");
        _;
    }

    function register() external payable notRegistered {
        require(msg.value == STAKE_AMOUNT, "Must stake exact amount");

        registered[msg.sender] = true;
        totalRegistrations++;

        emit Registered(msg.sender);
    }

    function refundStake(address payable user) external {
        require(msg.sender == admin, "Only admin can refund");
        require(registered[user], "User not registered");

        registered[user] = false;
        (bool success, ) = user.call{value: STAKE_AMOUNT}("");
        require(success, "Refund failed");

        emit StakeRefunded(user);
    }
}

/// @notice Attack contract simulating Sybil registration
contract SybilIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function sybilRegister() external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("register()")
        );
    }
}
