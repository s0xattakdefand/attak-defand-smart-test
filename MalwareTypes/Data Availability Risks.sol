// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title DataAvailabilityAttackDefense - Full Attack and Defense Simulation for Data Availability Risks in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Commit-Only Contract (Allows Commit Without Reveal)
contract InsecureDataCommitment {
    mapping(uint256 => bytes32) public committedRoots;
    uint256 public commitCounter;

    event DataCommitted(uint256 indexed id, bytes32 root);

    function commitDataRoot(bytes32 rootHash) external {
        committedRoots[commitCounter] = rootHash;
        emit DataCommitted(commitCounter, rootHash);
        commitCounter++;
    }
}

/// @notice Secure Data Availability Contract (Full Data Publication and Challenge Option)
contract SecureDataAvailability {
    address public immutable owner;
    mapping(uint256 => DataCommit) public dataCommits;
    uint256 public commitCounter;

    struct DataCommit {
        bytes32 root;
        bytes fullData;
        uint256 timestamp;
        bool challenged;
    }

    uint256 public constant CHALLENGE_PERIOD = 1 days;

    event DataCommitted(uint256 indexed id, bytes32 root, bytes data);
    event DataChallenged(uint256 indexed id, address challenger);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function commitFullData(bytes calldata fullData) external onlyOwner {
        bytes32 rootHash = keccak256(fullData);

        dataCommits[commitCounter] = DataCommit({
            root: rootHash,
            fullData: fullData,
            timestamp: block.timestamp,
            challenged: false
        });

        emit DataCommitted(commitCounter, rootHash, fullData);
        commitCounter++;
    }

    function challengeCommit(uint256 commitId, bytes calldata supposedData) external {
        DataCommit storage commit = dataCommits[commitId];
        require(block.timestamp <= commit.timestamp + CHALLENGE_PERIOD, "Challenge window expired");
        require(!commit.challenged, "Already challenged");
        require(keccak256(supposedData) != commit.root, "Valid data provided");

        commit.challenged = true;
        emit DataChallenged(commitId, msg.sender);
    }

    function verifyData(uint256 commitId) external view returns (bytes memory) {
        require(!dataCommits[commitId].challenged, "Data is challenged and invalid");
        return dataCommits[commitId].fullData;
    }
}

/// @notice Attack contract simulating missing data attack
contract DataAvailabilityIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function fakeCommit(bytes32 rootHash) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("commitDataRoot(bytes32)", rootHash)
        );
    }
}
