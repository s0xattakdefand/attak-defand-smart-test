// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title MessageRelayAttackDefense - Full Attack and Defense Simulation for Message Relay in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Message Relay Contract (No Replay Protection, No Source Verification)
contract InsecureMessageRelay {
    event MessageRelayed(address indexed sender, string message);

    function relayMessage(string calldata message) external {
        emit MessageRelayed(msg.sender, message);
        // BAD: No check for trusted sender, no nonce replay protection
    }
}

/// @notice Secure Message Relay Contract (Trusted Source + Nonce-Based Replay Protection)
contract SecureMessageRelay {
    address public immutable trustedRelayer;
    mapping(bytes32 => bool) public processedMessages;
    uint256 public chainId;

    event MessageRelayed(address indexed relayer, string message, uint256 indexed sourceChain, bytes32 messageHash);

    constructor(address _trustedRelayer) {
        trustedRelayer = _trustedRelayer;
        chainId = block.chainid;
    }

    function relayMessage(
        string calldata message,
        uint256 sourceChainId,
        uint256 nonce,
        bytes memory signature
    ) external {
        bytes32 messageHash = keccak256(abi.encodePacked(message, sourceChainId, nonce));
        require(!processedMessages[messageHash], "Message already processed");
        require(verifySignature(messageHash, signature) == trustedRelayer, "Invalid signature");

        processedMessages[messageHash] = true;
        emit MessageRelayed(trustedRelayer, message, sourceChainId, messageHash);
    }

    function verifySignature(bytes32 hash, bytes memory signature) internal pure returns (address) {
        return ECDSA.recover(ECDSA.toEthSignedMessageHash(hash), signature);
    }
}

/// @notice Attack contract simulating relay spoofing and replay
contract MessageRelayIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function spoofRelay(string calldata fakeMessage) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("relayMessage(string)", fakeMessage)
        );
    }
}

/// @notice Minimal ECDSA Helper Library
library ECDSA {
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        require(signature.length == 65, "Invalid sig length");
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }
        return ecrecover(hash, v, r, s);
    }

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}
