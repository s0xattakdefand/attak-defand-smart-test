// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title WormsAttackDefense - Full Attack and Defense Simulation for Worms in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Worm Contract (Vulnerable to Uncontrolled Replication)
contract InsecureWorm {
    address public admin;
    address[] public spawnedWorms;

    event WormSpawned(address indexed newWorm);

    constructor() {
        admin = msg.sender;
    }

    function spread() external {
        require(msg.sender == admin, "Only admin can spawn");

        InsecureWorm newWorm = new InsecureWorm();
        spawnedWorms.push(address(newWorm));

        emit WormSpawned(address(newWorm));
    }

    function getSpawnedWorms() external view returns (address[] memory) {
        return spawnedWorms;
    }
}

/// @notice Secure Worm Guard Contract (Limits and Hardens Replication)
contract SecureWormGuard {
    address public admin;
    uint256 public maxSpawns;
    uint256 public currentSpawns;
    mapping(address => bool) public registeredWorms;

    event WormSpawnedSecurely(address indexed newWorm);

    constructor(uint256 _maxSpawns) {
        admin = msg.sender;
        maxSpawns = _maxSpawns;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin");
        _;
    }

    function controlledSpread() external onlyAdmin {
        require(currentSpawns < maxSpawns, "Spawn limit reached");

        SecureWormGuard newWorm = new SecureWormGuard(0); // New worms cannot spawn
        registeredWorms[address(newWorm)] = true;
        currentSpawns += 1;

        emit WormSpawnedSecurely(address(newWorm));
    }

    function isRegistered(address worm) external view returns (bool) {
        return registeredWorms[worm];
    }
}

/// @notice Attack contract simulating worm spread
contract WormIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function massSpread(uint256 count) external {
        for (uint256 i = 0; i < count; i++) {
            (bool success, ) = targetInsecure.call(
                abi.encodeWithSignature("spread()")
            );
            require(success, "Spread failed");
        }
    }
}
