// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title EclipseAttackDefense - Full Attack and Defense Simulation for Eclipse Attacks in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Oracle Contract (Single Source Vulnerability - Eclipseable)
contract InsecureOracleSingleSource {
    address public oracleSource;
    uint256 public latestPrice;

    event PriceUpdated(address indexed source, uint256 price);

    constructor(address _oracleSource) {
        oracleSource = _oracleSource;
    }

    function updatePrice(uint256 price) external {
        require(msg.sender == oracleSource, "Only oracle can update");
        latestPrice = price;
        emit PriceUpdated(msg.sender, price);
    }

    function getPrice() external view returns (uint256) {
        return latestPrice;
    }
}

/// @notice Secure Multi-Source Oracle Contract (Anti-Eclipse Defense)
contract SecureOracleMultiSource {
    address public immutable owner;
    mapping(address => bool) public trustedOracles;
    uint256 public oracleCount;

    struct PriceReport {
        uint256 total;
        uint256 count;
    }

    mapping(uint256 => PriceReport) public priceReports;
    uint256 public currentRound;

    uint256 public constant MIN_ORACLE_REPORTS = 3;

    event OracleRegistered(address indexed oracle);
    event PriceReported(address indexed oracle, uint256 roundId, uint256 price);
    event FinalPriceSet(uint256 roundId, uint256 finalPrice);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier onlyTrustedOracle() {
        require(trustedOracles[msg.sender], "Not trusted oracle");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function registerOracle(address oracle) external onlyOwner {
        trustedOracles[oracle] = true;
        oracleCount++;
        emit OracleRegistered(oracle);
    }

    function reportPrice(uint256 price) external onlyTrustedOracle {
        priceReports[currentRound].total += price;
        priceReports[currentRound].count++;

        emit PriceReported(msg.sender, currentRound, price);

        if (priceReports[currentRound].count >= MIN_ORACLE_REPORTS) {
            uint256 finalPrice = priceReports[currentRound].total / priceReports[currentRound].count;
            emit FinalPriceSet(currentRound, finalPrice);
            currentRound++;
        }
    }

    function getCurrentRound() external view returns (uint256) {
        return currentRound;
    }
}

/// @notice Attack contract simulating eclipse fake oracle data
contract EclipseIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function feedFakePrice(uint256 fakePrice) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("updatePrice(uint256)", fakePrice)
        );
    }
}
