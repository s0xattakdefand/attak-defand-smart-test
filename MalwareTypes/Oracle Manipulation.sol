// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title OracleManipulationAttackDefense - Full Attack and Defense Simulation for Oracle Manipulation in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Oracle Consumer (Single Source - Vulnerable to Manipulation)
contract InsecureOracleConsumer {
    address public oracle;
    uint256 public lastPrice;

    event PriceFetched(uint256 price);

    constructor(address _oracle) {
        oracle = _oracle;
    }

    function fetchPrice() external {
        uint256 price = IOracle(oracle).getPrice();
        lastPrice = price;

        emit PriceFetched(price);
    }
}

interface IOracle {
    function getPrice() external view returns (uint256);
}

/// @notice Secure Oracle Aggregator (Multi-Source + TWAP Defense)
contract SecureOracleAggregator {
    address public immutable owner;
    address[] public oracles;
    mapping(address => bool) public trustedOracles;
    uint256 public lastUpdateTimestamp;
    uint256 public twapPrice;

    uint256 public constant MIN_UPDATE_INTERVAL = 5 minutes;

    event OracleAdded(address oracle);
    event OraclePriceReported(address oracle, uint256 price);
    event TWAPUpdated(uint256 twapPrice);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addOracle(address _oracle) external onlyOwner {
        require(_oracle != address(0), "Invalid address");
        trustedOracles[_oracle] = true;
        oracles.push(_oracle);
        emit OracleAdded(_oracle);
    }

    function updateTWAP() external {
        require(block.timestamp >= lastUpdateTimestamp + MIN_UPDATE_INTERVAL, "Update interval not reached");

        uint256 totalPrice = 0;
        uint256 sources = 0;

        for (uint256 i = 0; i < oracles.length; i++) {
            address oracleAddr = oracles[i];
            if (trustedOracles[oracleAddr]) {
                uint256 price = IOracle(oracleAddr).getPrice();
                totalPrice += price;
                sources++;
                emit OraclePriceReported(oracleAddr, price);
            }
        }

        require(sources > 0, "No trusted oracles available");

        twapPrice = totalPrice / sources;
        lastUpdateTimestamp = block.timestamp;

        emit TWAPUpdated(twapPrice);
    }

    function getCurrentPrice() external view returns (uint256) {
        return twapPrice;
    }
}

/// @notice Attack contract simulating manipulated oracle price feeding
contract OracleManipulationIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function forceManipulatedPrice() external {
        // Assume attacker controls the oracle contract itself
        IOracle(targetInsecure).getPrice();
        // Actual manipulation happens at the oracle contract level
    }
}
