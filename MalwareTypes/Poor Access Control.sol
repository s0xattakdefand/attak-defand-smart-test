// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title PoorAccessControlAttackDefense - Full Attack and Defense Simulation for Poor Access Control in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Access Control Contract (No Owner, Anyone Can Execute Critical Functions)
contract InsecureAccessControl {
    uint256 public totalMinted;
    mapping(address => uint256) public balances;

    event Mint(address indexed to, uint256 amount);
    event Withdraw(address indexed to, uint256 amount);

    function mint(address to, uint256 amount) external {
        totalMinted += amount;
        balances[to] += amount;
        emit Mint(to, amount);
    }

    function withdraw(address payable to, uint256 amount) external {
        require(address(this).balance >= amount, "Not enough balance");
        (bool success, ) = to.call{value: amount}("");
        require(success, "Withdraw failed");
        emit Withdraw(to, amount);
    }

    receive() external payable {}
}

/// @notice Secure Access Control Contract (Owner-Only and Role-Based Security)
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract SecureAccessControl is Ownable, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant TREASURER_ROLE = keccak256("TREASURER_ROLE");

    uint256 public totalMinted;
    mapping(address => uint256) public balances;

    event Mint(address indexed to, uint256 amount);
    event Withdraw(address indexed to, uint256 amount);

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {
        totalMinted += amount;
        balances[to] += amount;
        emit Mint(to, amount);
    }

    function withdraw(address payable to, uint256 amount) external onlyRole(TREASURER_ROLE) {
        require(address(this).balance >= amount, "Not enough balance");
        (bool success, ) = to.call{value: amount}("");
        require(success, "Withdraw failed");
        emit Withdraw(to, amount);
    }

    function grantMinter(address account) external onlyOwner {
        _grantRole(MINTER_ROLE, account);
    }

    function grantTreasurer(address account) external onlyOwner {
        _grantRole(TREASURER_ROLE, account);
    }

    receive() external payable {}
}

/// @notice Attack contract simulating direct call to mint or withdraw without permission
contract AccessControlIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function unauthorizedMint(address to, uint256 amount) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("mint(address,uint256)", to, amount)
        );
    }

    function unauthorizedWithdraw(address payable to, uint256 amount) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("withdraw(address,uint256)", to, amount)
        );
    }
}
