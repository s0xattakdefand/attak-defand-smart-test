// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title IcePhishingAttackDefense - Full Attack and Defense Simulation for Ice Phishing in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Approval Contract (Victim Approves Unlimited Spend to Attacker)
contract InsecureIcePhishing {
    address public attacker;

    event ApprovalTricked(address indexed victim, uint256 amount);

    constructor(address _attacker) {
        attacker = _attacker;
    }

    function fakeRewardClaim(address tokenAddress) external {
        // Victim approves attacker's address to spend all tokens
        IERC20(tokenAddress).approve(attacker, type(uint256).max);
        emit ApprovalTricked(msg.sender, type(uint256).max);
    }
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

/// @notice Secure Approval Contract (Explicit Approval to Safe Vault Only)
contract SecureApprovalVault {
    address public immutable vaultAddress;
    IERC20 public immutable token;

    event LimitedApprovalGranted(address indexed user, uint256 amount);

    constructor(address _token, address _vaultAddress) {
        token = IERC20(_token);
        vaultAddress = _vaultAddress;
    }

    function safeApproveLimited(uint256 amount) external {
        require(amount <= 10 ether, "Approval limit exceeded");
        token.approve(vaultAddress, amount);
        emit LimitedApprovalGranted(msg.sender, amount);
    }
}

/// @notice Attack contract simulating ice phishing lure
contract IcePhishingIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function triggerFakeReward(address tokenAddress) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("fakeRewardClaim(address)", tokenAddress)
        );
    }
}
