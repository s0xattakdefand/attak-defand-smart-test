// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title ExoticsAttackDefense - Full Attack and Defense Simulation for Exotic Mechanisms in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Exotic Option (Complex, exploitable payoff logic)
contract InsecureExoticOption {
    address public owner;
    uint256 public strikePrice;
    uint256 public payoutMultiplier;

    event OptionExercised(address indexed user, uint256 payout);

    constructor(uint256 _strikePrice, uint256 _multiplier) {
        owner = msg.sender;
        strikePrice = _strikePrice;
        payoutMultiplier = _multiplier;
    }

    function exercise(uint256 assetPrice) external {
        uint256 payout = 0;
        if (assetPrice > strikePrice) {
            payout = (assetPrice - strikePrice) * payoutMultiplier;
        }
        payable(msg.sender).transfer(payout);
        emit OptionExercised(msg.sender, payout);
    }

    // Receive funding for payouts
    receive() external payable {}
}

/// @notice Secure Exotic Option (Boundary Checks + Oracle Validation + Payoff Safeguards)
contract SecureExoticOption {
    address public immutable owner;
    uint256 public strikePrice;
    uint256 public payoutMultiplier;
    address public trustedOracle;
    uint256 public constant MAX_PAYOUT = 10 ether;

    event OptionExercised(address indexed user, uint256 payout);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    constructor(uint256 _strikePrice, uint256 _multiplier, address _oracle) {
        owner = msg.sender;
        strikePrice = _strikePrice;
        payoutMultiplier = _multiplier;
        trustedOracle = _oracle;
    }

    function setOracle(address newOracle) external onlyOwner {
        trustedOracle = newOracle;
    }

    function exercise() external {
        uint256 assetPrice = IPriceOracle(trustedOracle).getLatestPrice();
        require(assetPrice > strikePrice, "No payout, asset below strike");

        uint256 rawPayout = (assetPrice - strikePrice) * payoutMultiplier;
        uint256 finalPayout = rawPayout > MAX_PAYOUT ? MAX_PAYOUT : rawPayout;

        require(address(this).balance >= finalPayout, "Insufficient funds");

        payable(msg.sender).transfer(finalPayout);
        emit OptionExercised(msg.sender, finalPayout);
    }

    receive() external payable {}
}

interface IPriceOracle {
    function getLatestPrice() external view returns (uint256);
}

/// @notice Attack contract simulating boundary exploitation on exotic options
contract ExoticIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function fakeHighAssetPrice(uint256 fakePrice) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("exercise(uint256)", fakePrice)
        );
    }
}
