// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title RansomwareAttackDefense - Full Attack and Defense Simulation for Ransomware Vulnerabilities in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Ransomware Contract (Vulnerable to Forced Lock + Ransom Demand)
contract InsecureRansomware {
    address public attacker;
    bool public locked;
    uint256 public ransomAmount;
    address public ransomReceiver;

    mapping(address => uint256) public balances;

    constructor() {
        attacker = msg.sender;
        ransomReceiver = msg.sender;
    }

    function deposit() external payable {
        require(!locked, "System locked!");
        balances[msg.sender] += msg.value;
    }

    function triggerRansom(uint256 _amount) external {
        require(msg.sender == attacker, "Only attacker");
        ransomAmount = _amount;
        locked = true;
    }

    function payRansom() external payable {
        require(locked, "Not locked");
        require(msg.value == ransomAmount, "Incorrect ransom amount");

        (bool sent, ) = ransomReceiver.call{value: ransomAmount}("");
        require(sent, "Payment failed");

        locked = false;
    }

    function withdraw() external {
        require(!locked, "System locked!");
        uint256 amount = balances[msg.sender];
        require(amount > 0, "Nothing to withdraw");

        balances[msg.sender] = 0;
        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Withdraw failed");
    }

    receive() external payable {}
}

/// @notice Secure Anti-Ransomware Contract (Hardened with Immutable and Recovery Controls)
contract SecureAntiRansomware {
    address public admin;
    address public recoveryMultisig;
    bool public permanentlyUnlocked;

    mapping(address => uint256) public balances;

    event EmergencyUnlocked(address indexed by);

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin");
        _;
    }

    constructor(address _recoveryMultisig) {
        admin = msg.sender;
        recoveryMultisig = _recoveryMultisig;
        permanentlyUnlocked = true;
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function emergencyUnlock() external {
        require(msg.sender == recoveryMultisig, "Only recovery multisig");
        permanentlyUnlocked = true;
        emit EmergencyUnlocked(msg.sender);
    }

    function withdraw() external {
        require(permanentlyUnlocked, "System temporarily frozen");
        uint256 amount = balances[msg.sender];
        require(amount > 0, "Nothing to withdraw");

        balances[msg.sender] = 0;
        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Withdraw failed");
    }

    receive() external payable {}
}

/// @notice Attack contract trying to ransom users
contract RansomwareIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function launchRansom(uint256 amount) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("triggerRansom(uint256)", amount)
        );
    }
}
