// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title HijackwareAttackDefense - Full Attack and Defense Simulation for Hijackware in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Hijackware Contract (Hidden Ownership Hijack)
contract InsecureHijackware {
    address public owner;
    address public hijacker;

    event OwnershipChanged(address indexed oldOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) external {
        require(msg.sender == owner, "Only owner");
        owner = newOwner;
        emit OwnershipChanged(msg.sender, newOwner);
    }

    function hiddenHijack() external {
        // BAD: Anyone can claim ownership if hijacker address set
        require(hijacker != address(0), "Hijacker not set");
        owner = hijacker;
        emit OwnershipChanged(msg.sender, hijacker);
    }

    function setHijacker(address _hijacker) external {
        require(msg.sender == owner, "Only owner");
        hijacker = _hijacker;
    }
}

/// @notice Secure Ownership Contract (Explicit Two-Step Ownership Acceptance)
contract SecureOwnership {
    address public owner;
    address public pendingOwner;

    event OwnershipTransferInitiated(address indexed currentOwner, address indexed newOwner);
    event OwnershipTransferCompleted(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function initiateOwnershipTransfer(address newOwner) external onlyOwner {
        pendingOwner = newOwner;
        emit OwnershipTransferInitiated(owner, newOwner);
    }

    function acceptOwnership() external {
        require(msg.sender == pendingOwner, "Not pending owner");
        emit OwnershipTransferCompleted(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}

/// @notice Attack contract simulating hijack attempt
contract HijackIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function launchHijack() external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("hiddenHijack()")
        );
    }
}
