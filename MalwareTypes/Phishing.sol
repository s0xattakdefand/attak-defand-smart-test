// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title PhishingAttackDefense - Full Attack and Defense Simulation for Phishing in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Token Approval Contract (Susceptible to Phishing)
contract InsecurePhishingApproval {
    mapping(address => uint256) public allowances;

    event Approved(address indexed user, address indexed spender, uint256 amount);

    function approve(address spender, uint256 amount) external {
        // BAD: No restriction, users might approve malicious contracts
        allowances[spender] = amount;
        emit Approved(msg.sender, spender, amount);
    }

    function spend(address spender, uint256 amount) external {
        require(allowances[spender] >= amount, "Not enough allowance");
        allowances[spender] -= amount;
    }
}

/// @notice Secure Token Approval Contract (Limited Allowance, Trusted Spender Only)
contract SecurePhishingProtected {
    mapping(address => uint256) public allowances;
    address public immutable trustedSpender;
    uint256 public constant MAX_APPROVAL = 1000 ether;

    event Approved(address indexed user, address indexed spender, uint256 amount);

    constructor(address _trustedSpender) {
        trustedSpender = _trustedSpender;
    }

    function approve(address spender, uint256 amount) external {
        require(spender == trustedSpender, "Only trusted spender allowed");
        require(amount <= MAX_APPROVAL, "Exceeds safe approval limit");

        allowances[spender] = amount;
        emit Approved(msg.sender, spender, amount);
    }

    function spend(address spender, uint256 amount) external {
        require(spender == trustedSpender, "Invalid spender");
        require(allowances[spender] >= amount, "Not enough allowance");

        allowances[spender] -= amount;
    }
}

/// @notice Attack contract simulating phishing approval capture
contract PhishingIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function requestFakeApproval(uint256 fakeAmount) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("approve(address,uint256)", address(this), fakeAmount)
        );
    }

    function stealTokens(uint256 amount) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("spend(address,uint256)", address(this), amount)
        );
    }
}
