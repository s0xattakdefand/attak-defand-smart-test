// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title MobileMalwareAttackDefense - Full Attack and Defense Simulation for Mobile Malware in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Contract (Vulnerable to Transaction Drift / Mobile Malware Exploits)
contract InsecureMobileMalwareTarget {
    address public admin;
    mapping(address => uint256) public deposits;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed to, uint256 amount);

    constructor() {
        admin = msg.sender;
    }

    function deposit() external payable {
        deposits[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(address payable recipient, uint256 amount) external {
        require(deposits[msg.sender] >= amount, "Insufficient balance");
        deposits[msg.sender] -= amount;

        (bool sent, ) = recipient.call{value: amount}("");
        require(sent, "Withdraw failed");

        emit Withdraw(recipient, amount);
    }

    receive() external payable {}
}

/// @notice Secure Contract with Mobile Malware Protection (Fixed Recipient + Integrity Check)
contract SecureMobileMalwareTarget {
    address public admin;
    mapping(address => uint256) private deposits;
    mapping(address => address) private approvedRecipient;

    event DepositRecorded(address indexed user, uint256 amount);
    event WithdrawalCompleted(address indexed user, uint256 amount, address indexed recipient);

    constructor() {
        admin = msg.sender;
    }

    function deposit(address recipient) external payable {
        require(recipient != address(0), "Recipient cannot be zero");
        require(approvedRecipient[msg.sender] == address(0), "Already registered");

        deposits[msg.sender] += msg.value;
        approvedRecipient[msg.sender] = recipient;

        emit DepositRecorded(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        address recipient = approvedRecipient[msg.sender];
        require(recipient != address(0), "Recipient not set");
        require(deposits[msg.sender] >= amount, "Insufficient balance");

        deposits[msg.sender] -= amount;
        (bool sent, ) = recipient.call{value: amount}("");
        require(sent, "Withdraw failed");

        emit WithdrawalCompleted(msg.sender, amount, recipient);
    }

    function getMyBalance() external view returns (uint256) {
        return deposits[msg.sender];
    }

    receive() external payable {}
}

/// @notice Mobile Malware Simulated Attacker (Clipboard Swap and Transaction Drift)
contract MobileMalwareIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function hijackWithdraw(address payable attackerAddress) external {
        // Try to replace intended recipient address with attacker's address
        (bool success, ) = targetInsecure.call(
            abi.encodeWithSignature("withdraw(address,uint256)", attackerAddress, 0.1 ether)
        );
        require(success, "Hijack failed");
    }
}
