// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title FlashLoanAttackDefense - Full Attack and Defense Simulation for Flash Loan Attacks in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Vault (Vulnerable to Flash Loan Price Manipulation)
contract InsecureVault {
    mapping(address => uint256) public deposits;
    uint256 public totalDeposits;
    uint256 public vaultValue; // supposed stable

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    constructor() {
        vaultValue = 100 ether;
    }

    function deposit() external payable {
        deposits[msg.sender] += msg.value;
        totalDeposits += msg.value;
        vaultValue += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        require(deposits[msg.sender] >= amount, "Insufficient balance");
        deposits[msg.sender] -= amount;
        totalDeposits -= amount;
        payable(msg.sender).transfer(amount);
        vaultValue -= amount;
        emit Withdrawal(msg.sender, amount);
    }

    function getVaultValue() external view returns (uint256) {
        return vaultValue;
    }

    receive() external payable {}
}

/// @notice Secure Vault (TWAP + Snapshot + Anti-Flash Loan Guard)
contract SecureVault {
    address public immutable owner;
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public snapshots;
    uint256 public totalDeposits;
    uint256 public vaultValue;
    uint256 public lastUpdateTimestamp;

    uint256 public constant TWAP_WINDOW = 15 minutes;
    uint256 public constant MIN_WITHDRAW_DELAY = 5 minutes;

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    constructor() {
        owner = msg.sender;
        vaultValue = 100 ether;
        lastUpdateTimestamp = block.timestamp;
    }

    function deposit() external payable {
        require(msg.value > 0, "Zero deposit");
        updateSnapshot(msg.sender);

        deposits[msg.sender] += msg.value;
        totalDeposits += msg.value;
        vaultValue += msg.value;

        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        require(block.timestamp > snapshots[msg.sender] + MIN_WITHDRAW_DELAY, "Too soon after deposit");
        require(deposits[msg.sender] >= amount, "Insufficient balance");

        deposits[msg.sender] -= amount;
        totalDeposits -= amount;
        vaultValue -= amount;

        payable(msg.sender).transfer(amount);

        emit Withdrawal(msg.sender, amount);
    }

    function updateSnapshot(address user) internal {
        snapshots[user] = block.timestamp;
    }

    function getVaultValue() external view returns (uint256) {
        return vaultValue;
    }

    receive() external payable {}
}

/// @notice Attack contract simulating flash loan manipulation
contract FlashLoanIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function manipulateVault() external payable {
        // Simulate depositing flash-loaned funds to manipulate vault temporarily
        targetInsecure.call{value: msg.value}(
            abi.encodeWithSignature("deposit()")
        );
        // Withdraw back immediately
        targetInsecure.call(
            abi.encodeWithSignature("withdraw(uint256)", msg.value)
        );
    }
}
