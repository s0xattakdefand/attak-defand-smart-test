// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title GraywareAttackDefense - Full Attack and Defense Simulation for Grayware in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Grayware Contract (Hidden Fees and Lock-ins)
contract InsecureGrayware {
    uint256 public constant HIDDEN_FEE_PERCENT = 2; // 2% hidden fee
    address public owner;
    mapping(address => uint256) public deposits;

    event DepositMade(address indexed user, uint256 amountAfterFee);
    event HiddenFeeCollected(address indexed owner, uint256 fee);

    constructor() {
        owner = msg.sender;
    }

    function deposit() external payable {
        require(msg.value > 0, "Zero deposit");
        uint256 fee = (msg.value * HIDDEN_FEE_PERCENT) / 100;
        uint256 netDeposit = msg.value - fee;

        deposits[msg.sender] += netDeposit;
        payable(owner).transfer(fee);

        emit HiddenFeeCollected(owner, fee);
        emit DepositMade(msg.sender, netDeposit);
    }

    function withdraw(uint256 amount) external {
        require(deposits[msg.sender] >= amount, "Insufficient balance");
        deposits[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
}

/// @notice Secure Transparent Contract (Explicit Fee Opt-in + Withdrawable Anytime)
contract SecureTransparentContract {
    address public immutable owner;
    mapping(address => uint256) public deposits;

    uint256 public constant FEE_PERCENT = 2; // 2% fee
    bool public constant FEE_ENABLED = true;

    event DepositMade(address indexed user, uint256 netAmount, uint256 fee);
    event Withdrawal(address indexed user, uint256 amount);

    constructor() {
        owner = msg.sender;
    }

    function deposit() external payable {
        require(msg.value > 0, "Zero deposit");

        uint256 fee = FEE_ENABLED ? (msg.value * FEE_PERCENT) / 100 : 0;
        uint256 netAmount = msg.value - fee;

        deposits[msg.sender] += netAmount;
        if (fee > 0) {
            payable(owner).transfer(fee);
        }

        emit DepositMade(msg.sender, netAmount, fee);
    }

    function withdraw(uint256 amount) external {
        require(deposits[msg.sender] >= amount, "Insufficient balance");

        deposits[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);

        emit Withdrawal(msg.sender, amount);
    }
}

/// @notice Attack contract simulating fee exploitation via repetitive deposits
contract GraywareIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function spamDeposits() external payable {
        for (uint8 i = 0; i < 5; i++) {
            targetInsecure.call{value: msg.value / 5}(
                abi.encodeWithSignature("deposit()")
            );
        }
    }
}
