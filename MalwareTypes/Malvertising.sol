// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title MalvertisingAttackDefense - Full Attack and Defense Simulation for Malvertising in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Malvertising Contract (Fake Airdrop Claim Trap)
contract InsecureMalvertising {
    address public attacker;

    event Claimed(address indexed victim, uint256 stolenAmount);

    constructor(address _attacker) {
        attacker = _attacker;
    }

    function claimAirdrop() external payable {
        // BAD: victim thinks claiming an airdrop, but sends ETH to attacker
        require(msg.value >= 0.01 ether, "Minimal ETH required");
        payable(attacker).transfer(msg.value);
        emit Claimed(msg.sender, msg.value);
    }

    receive() external payable {}
}

/// @notice Secure Airdrop Contract (Explicit Validation and No Malicious Drain)
contract SecureAirdrop {
    address public immutable owner;
    mapping(address => bool) public hasClaimed;
    uint256 public constant AIRDROP_AMOUNT = 0.05 ether;

    event AirdropClaimed(address indexed user, uint256 amount);

    constructor() payable {
        owner = msg.sender;
    }

    function claim() external {
        require(!hasClaimed[msg.sender], "Already claimed");
        require(address(this).balance >= AIRDROP_AMOUNT, "Insufficient airdrop balance");

        hasClaimed[msg.sender] = true;
        payable(msg.sender).transfer(AIRDROP_AMOUNT);

        emit AirdropClaimed(msg.sender, AIRDROP_AMOUNT);
    }

    function fundAirdrop() external payable {
        require(msg.sender == owner, "Only owner");
    }
}

/// @notice Attack contract simulating fake claim injection
contract MalvertisingIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function triggerFakeClaim() external payable returns (bool success) {
        (success, ) = targetInsecure.call{value: msg.value}(
            abi.encodeWithSignature("claimAirdrop()")
        );
    }
}
