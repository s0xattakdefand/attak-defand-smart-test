// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title RootkitAttackDefense - Full Attack and Defense Simulation for Rootkits in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Rootkit Contract (Contains Hidden Admin Backdoors)
contract InsecureRootkitContract {
    address private owner; // BAD: private + upgradable
    bool private backdoorEnabled;

    event SafeAction(address indexed user);

    constructor() {
        owner = msg.sender;
    }

    fallback() external payable {
        if (backdoorEnabled && msg.sender == owner) {
            (bool success, ) = msg.sender.call{value: address(this).balance}("");
            require(success, "Backdoor transfer failed");
        }
    }

    function safeAction() external {
        emit SafeAction(msg.sender);
    }

    function enableBackdoor() external {
        require(msg.sender == owner, "Only owner");
        backdoorEnabled = true;
    }

    function changeOwner(address newOwner) external {
        require(msg.sender == owner, "Only owner");
        owner = newOwner; // Hidden owner change possible anytime!
    }

    receive() external payable {}
}

/// @notice Secure Anti-Rootkit Contract (No Hidden Ownership or Fallback Abuse)
contract SecureAntiRootkitContract {
    address public immutable admin;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);

    mapping(address => uint256) private balances;

    constructor() {
        admin = msg.sender;
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Not enough balance");

        balances[msg.sender] -= amount;
        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Withdraw failed");

        emit Withdraw(msg.sender, amount);
    }

    function getMyBalance() external view returns (uint256) {
        return balances[msg.sender];
    }

    receive() external payable {}

    fallback() external payable {
        revert("Fallback disabled");
    }
}

/// @notice Attack contract trying to trigger hidden rootkit backdoors
contract RootkitIntruder {
    address public targetRootkit;

    constructor(address _targetRootkit) {
        targetRootkit = _targetRootkit;
    }

    function activateBackdoor() external returns (bool success) {
        (success, ) = targetRootkit.call(
            abi.encodeWithSignature("enableBackdoor()")
        );
    }

    function triggerFallbackDrain() external payable returns (bool success) {
        (success, ) = targetRootkit.call{value: 0}("");
    }
}
