// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title FiftyOneAttackDefense - Full Attack and Defense Simulation for 51% Attack in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure DAO Contract (Simple 51% Voting Attackable)
contract InsecureSimpleDAO {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    address public treasury;

    event ProposalPassed(address indexed attacker, uint256 amount);

    constructor() {
        treasury = address(this);
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        totalSupply += msg.value;
    }

    function attackProposal(address payable recipient, uint256 amount) external {
        require(balances[msg.sender] > totalSupply / 2, "Need >51% control");
        require(address(this).balance >= amount, "Insufficient treasury");

        recipient.transfer(amount);
        emit ProposalPassed(msg.sender, amount);
    }
    
    receive() external payable {}
}

/// @notice Secure DAO Contract (Threshold Voting + Delay + Slashing Mechanism)
contract SecureDAO {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    address public immutable owner;
    uint256 public proposalCount;

    struct Proposal {
        address proposer;
        address payable target;
        uint256 amount;
        uint256 yesVotes;
        uint256 creationTime;
        bool executed;
    }

    mapping(uint256 => Proposal) public proposals;

    uint256 public constant MIN_DELAY = 1 days;
    uint256 public constant SUPERMAJORITY = 67; // Require >67% votes

    event ProposalCreated(uint256 indexed proposalId, address proposer, address target, uint256 amount);
    event ProposalExecuted(uint256 indexed proposalId, address target, uint256 amount);

    constructor() {
        owner = msg.sender;
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        totalSupply += msg.value;
    }

    function createProposal(address payable target, uint256 amount) external returns (uint256) {
        require(balances[msg.sender] > 0, "Must be a depositor");

        proposals[proposalCount] = Proposal({
            proposer: msg.sender,
            target: target,
            amount: amount,
            yesVotes: balances[msg.sender],
            creationTime: block.timestamp,
            executed: false
        });

        emit ProposalCreated(proposalCount, msg.sender, target, amount);
        proposalCount++;

        return proposalCount - 1;
    }

    function voteProposal(uint256 proposalId) external {
        Proposal storage prop = proposals[proposalId];
        require(!prop.executed, "Already executed");
        require(balances[msg.sender] > 0, "No vote power");

        prop.yesVotes += balances[msg.sender];
    }

    function executeProposal(uint256 proposalId) external {
        Proposal storage prop = proposals[proposalId];
        require(!prop.executed, "Already executed");
        require(block.timestamp >= prop.creationTime + MIN_DELAY, "Proposal delay not met");
        require(prop.yesVotes * 100 / totalSupply >= SUPERMAJORITY, "Not enough yes votes");
        require(address(this).balance >= prop.amount, "Insufficient treasury");

        prop.executed = true;
        prop.target.transfer(prop.amount);

        emit ProposalExecuted(proposalId, prop.target, prop.amount);
    }

    receive() external payable {}
}

/// @notice Attack contract simulating 51% control attempt
contract FiftyOneIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function launchTakeover(address payable recipient, uint256 amount) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("attackProposal(address,uint256)", recipient, amount)
        );
    }
}
